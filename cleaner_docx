import io
import zipfile
import tempfile
from lxml import etree
from docx import Document

NAMESPACES = {
    'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
}

def _print_diagnostics(xml, filename):
    def count(tag): return len(xml.xpath(f'//w:{tag}', namespaces=NAMESPACES))
    print(f"📄 {filename}")
    print(f"  🗨️ Comments:               {count('commentReference')}")
    print(f"  ➕ Insertions:             {count('ins')}")
    print(f"  ➖ Deletions:              {count('del')}")
    print(f"  🔁 Moves:                  {count('moveFrom') + count('moveTo')}")
    print(f"  🎨 Formatting revisions:   {count('rPrChange') + count('pPrChange') + count('tblPrChange')}")
    print("")

def _clean_xml_part(xml_data: bytes, diagnostics: bool, filename: str) -> bytes:
    xml = etree.fromstring(xml_data)

    if diagnostics:
        _print_diagnostics(xml, filename)

    # Accept tracked insertions
    for ins in xml.xpath('//w:ins', namespaces=NAMESPACES):
        parent = ins.getparent()
        index = parent.index(ins)
        for child in list(ins):
            parent.insert(index, child)
            index += 1
        parent.remove(ins)

    # Remove deletions
    for tag in ['del', 'moveFrom', 'moveTo',
                'commentRangeStart', 'commentRangeEnd', 'commentReference',
                'rPrChange', 'pPrChange', 'tblPrChange',
                'proofErr', 'permStart', 'permEnd', 'bookmarkStart', 'bookmarkEnd', 'trackChanges']:
        for elem in xml.xpath(f'//w:{tag}', namespaces=NAMESPACES):
            elem.getparent().remove(elem)

    return etree.tostring(xml, encoding='UTF-8', xml_declaration=True, standalone="yes")

def clean_docx_from_bytes(uploadFile: bytes, diagnostics: bool = False) -> Document:
    """
    Cleans a DOCX file from memory:
    - Accepts tracked changes
    - Removes comments and formatting revisions
    - Dynamically handles headers and footers
    - Returns a python-docx.Document object

    Parameters:
        uploadFile (bytes): DOCX file content (from upload or buffer)
        diagnostics (bool): Whether to print a diagnostic summary

    Returns:
        Document: Cleaned python-docx Document object
    """
    # Read input DOCX from memory buffer
    input_buffer = io.BytesIO(uploadFile)

    # Create temp output DOCX in memory
    output_buffer = io.BytesIO()

    with zipfile.ZipFile(input_buffer, 'r') as zin:
        # Discover all parts that may contain comments/revisions
        editable_parts = [item.filename for item in zin.infolist()
                          if item.filename.startswith('word/') and (
                              item.filename == 'word/document.xml' or
                              item.filename.startswith('word/header') or
                              item.filename.startswith('word/footer') or
                              item.filename == 'word/comments.xml')]

        with zipfile.ZipFile(output_buffer, 'w', zipfile.ZIP_DEFLATED) as zout:
            for item in zin.infolist():
                data = zin.read(item.filename)

                if item.filename in editable_parts:
                    if item.filename == 'word/comments.xml':
                        data = b''  # Clear comments completely
                    else:
                        data = _clean_xml_part(data, diagnostics, item.filename)

                zout.writestr(item, data)

    # Load the cleaned DOCX into python-docx
    output_buffer.seek(0)
    return Document(output_buffer)
